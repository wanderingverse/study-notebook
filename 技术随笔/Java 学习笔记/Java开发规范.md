# 引言
现代软件架构具有极高的复杂性，需要协同开发完成，如何解决高效协同开发问题呢？对软件来说，制定适当的规范和标准绝不是消灭代码内容的创造性和优雅性，而是限制代码的过度个性化，以一种普遍认可的、科学合理的统一方式，提升协作效率，降低沟通成本，提升系统稳定性。
## 规范Java开发的必要性
* 提高代码稳定性、健壮性和可维护性。
* 多人间高效协同开发。
* 提高软件的最终交付质量。
## 不规范开发存在的常见问题
1. 随意定义的错误码，增加排查问题的难度。
2. 数据库的表结构和索引设计有缺陷，带来系统架构缺陷或性能风险。
3. 工程结构混乱，后续项目维护艰难。
4. 没有鉴权的漏洞代码，易被黑客攻击。
# 编程规约
## 命名风格
* 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
* 【强制】代码中的命名均不能使用拼音与英文混合的方式，更不允许直接使用中文或纯拼音命名的方式（国际通用的非英文名称允许使用）。
* 【强制】代码中的命名不能随意缩写，而是尽量使用完整的单词组合，力求见名知意。
* 【强制】类名命名使用 UpperCamelCase 风格（大驼峰命名法）。
* 【强制】抽象类命名使用 Abstract或Base 开头。
* 【强制】异常类命名使用 Exception 结尾。
* 【强制】测试类命名以要测试的类名开始，以 Test 结尾。
* 【强制】方法名、参数名、成员变量、局部变量命名使用 lowerCamelCase 风格（小驼峰命名法）。
* 【强制】常量命名时字母全大写，单词间用下划线分隔，力求语义表达完整清楚。
* 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，且使用单数形式。
* 【强制】项目名统一使用大驼峰命名。
* 【强制】常量和变量在命名时，表示类型的名词放在词尾。
* 【强制】接口和实现类命名时，暴露出的服务必须是接口，接口对应的实现类用 Impl 后缀与接口区别。
* 【强制】枚举类名需携带 Enum 作为后缀；枚举成员名称全大写，单词间用下划线隔开（参考常量命名规范）。
* 【强制】查询方法用 get 做前缀。
* 【强制】插入方法用 insert 做前缀。
* 【强制】删除方法用 delete 做前缀。
* 【强制】修改方法用 update 做前缀。
* 【强制】数据对象实体类用 PO 做后缀，完整类名的组成部分为：数据表名 + PO。
* 【强制】数据传输对象实体类用 DTO 做后缀。请求数据传输对象用 RequestDTO 做后缀，响应数据传输对象用 ResponseDTO 做后缀。
* 【强制】config 类的命名为：名称+Config。
* 【强制】SpringBoot 项目目录结构规范：
	* controller
	* service
		* impl
	* mapper
	* model：
		* bo：Business Object，存放业务对象实体类（`{实体类名}BO.java`）。
		* entity：存放数据对象实体类（`{数据表名}DO.java`）
		* dto：存放数据传输对象实体类
			* request：存放请求数据传输对象（`{请求数据传输对象名}RequestDTO.java`）
			* response：存放响应数据传输对象（`{响应数据传输对象名}ResponseDTO.java`）
	* config：存放配置类、常量类、枚举类
	* common：存放通用类、工具类
* 【强制】SpringBoot 资源目录（`src/main/resource`）结构规范：
	* templates：存放导出功能相关的文件模板。
## 常量定义
* 【强制】不允许任何魔法值（即未经预定义的常量）出现在代码中。
* 【强制】业务需要的常量，按功能维护在以 Const 为类名后缀的常量类中，不要使用一个常量类维护所有常量。
## 代码格式
* 【强制】采用 4 个空格缩进代码。
* 【强制】单行注释的双斜线与注释内容之间有且仅有一个空格。
* 【强制】单个方法的总行数不超过 100 行。主方法力求功能核心、逻辑清晰。其他逻辑代码按模块抽离为额外方法，由主方法调用。
* 【推荐】不同逻辑、不同语义、不同业务的代码之间插入空行分隔，以提升可读性。
## 面向对象
* 【强制】不允许通过一个类的对象引用访问此类的静态变量或静态方法，而是直接用此类的类名访问。
* 【强制】所有的覆写方法必须加 @Override 注解。
* 【强制】非必要禁止使用 Object 作为数据类型。
* 【强制】非必要禁止在方法参数中使用可变参数。
* 【强制】所有的过时接口或方法必须加 @Deprecated 注解，并清晰说明应当使用的新接口或新服务。
* 【强制】非必要禁止使用过时的接口或方法。
* 【强制】所有引用类型对象之间值的比较，全部使用equals方法比较，且所有涉及到对象之间需要值比较的类，该类中必须重写 equals 和 hashcode 方法，并根据业务需要重写 toString 方法。
* 【强制】任何货币金额，均以最小货币单位的整型类型进行存储。
* 【强制】浮点类型之间禁止做等值判断（无论使用 == 还是 equals 方法），而是指定一个误差范围，两个浮点数的差值如若在此范围之内，则认为相等。或使用 BigDecimal 类定义浮点数据，在比较时通过 compareTo() 方法进行比较。
* 【强制】使用BigDecimal 类转换浮点数据时，使用 BigDecimal.valueOf(浮点数据) 进行转换，而非直接 new BigDecimal(浮点数据)；
* 【强制】数据对象实体类 DO 和数据传输对象实体类 DTO 中的所有属性，必须使用包装数据类型，且不允许设定任何属性默认值。
* 【强制】构造方法中禁止加入任何业务逻辑，如果有初始化逻辑，请自定义额外的 init 方法执行。
* 【强制】在 setter/getter 方法中，参数名称要与类成员变量名称一致，且禁止在 setter/getter 方法中增加业务逻辑。
* 【推荐】任何类、方法、参数、变量，都需要严格控制访问范围。因为过于宽泛的访问范围，不利于模块解耦。
## 日期时间
- 【强制】表示日期和时间的完整格式必须指定为："yyyy-MM-dd HH:mm:ss"，尤其注意大小写。
## 集合处理
- 【强制】所有判断集合内部的元素是否为空，使用isEmpty()方法，而不是size() == 0 的方式。
- 【强制】禁止在 foreach 循环里对循环元素本身进行 remove/add 操作。remove 元素请使用 Iterator 方式。如果并发操作，需要对 Iterator 对象加锁。
## 并发处理
- 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
- 【强制】线程池不允许使用 Executors 创建，而是通过 ThreadPoolExecutor 的方式。以此明确线程池的运行规则，规避资源耗尽的风险。
- 【强制】必须回收自定义的 ThreadLocal 变量。在线程池场景下，线程经常会被复用， 如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。
- 【强制】并发修改同一记录时需要加锁。如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。
- 【强制】敏感信息如金融信息，使用悲观锁策略，遵循一锁、二判、三更新、四释放的原则。 因为乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常。
- 【强制】在高并发场景中，避免使用 “等于=” 判断作为中断或退出的条件。因为如果并发控制没有处理好，容易产生等值判断被 “击穿” 的情况。应使用大于或小于的区间判断条件。
## 控制语句
- 【强制】在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止。
- 【强制】没个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。
- 【强制】表达异常或逻辑的分支，非必要禁止使用 if-else 方式，而是使用卫语句、策略模式、状态模式等实现。
- 【强制】循环体中的语句要考量性能。如定义对象、定义变量、 获取数据库连接、try-catch 等操作尽量移至循环体外处理。创建对象和变量时，可以通过在循环体外预先创建出后存储在集合（如列表）中，循环体中只处理赋值逻辑，以此避免每次循环都进行创建和销毁，减少内存分配和垃圾回收的开销。
- 【强制】公开接口的入参必须进行参数校验。且在 Controller 层利用参数校验注解做基础校验，抛出异常供全局异常处理器统一返回错误响应；在 Service 层进行业务相关的参数校验，直接 return 返回错误码和错误消息。
- 【推荐】避免采用取反逻辑运算符，不利于快速理解。
## 注释规约
- 【强制】类、类属性、类方法、枚举类型字段上的注释必须使用 Javadoc 规范，即使用：/** 内容*/ 的形式，不得使用 // 形式。
- 【强制】所有的抽象方法（包括接口中的方法）必须使用 Javadoc 注释、且除了说明抽象方法要求的返回值、参数和异常说明外，还必须指出该方法的目的和功能。
- 【强制】所有的类都必须添加创建者和创建日期，日期统一设置为 yyyy/MM/dd 的格式。
- 【强制】方法内部代码使用单行或多行注释。需在被注释语句上方书写。
- 【推荐】对于注释书写的要求，第一，反映设计思想和代码逻辑。第二，描述业务功能。
- 【推荐】好的命名和代码结构是自解释的，注释力求精简准确、表达到位。注释不要过于冗余，语义清晰的代码不需要额外的注释。
- 【使用】使用待办注释标记 // TODO 和 错误注释标记 //FIXME 标记代码，并及时实现或修复。
## 前后端规约
- 【强制】需要前后端交互的API，需要明确协议、域名、路径、请求方法、请求内容、状态码和响应体。
	- 协议：说明是 HTTP 还是 HTTPS 。生产环境必须使用 HTTPS。
	- 路径：每个 API 都需要明确对应请求路径，表示 API 具体的请求地址。
		- 请求路径的命名使用名词或名词复数，不能为动词，因为请求方法已经表达动作意义。
		- 请求路径的命名不允许使用大写。各单词间如果需要分隔，统一使用**连接符-**。
		- 请求路径禁止携带表示请求内容类型的后缀，如 ".json"，".xml"，此类内容通过 accept 头表达即可。
	- 请求方法：请求方法描述一个API表达的操作或动作定义，遵循 RESTful 风格。
		- GET：从服务器获取资源。
		- POST：在服务器新建资源。
		- PUT：在服务器更新资源。
		- DELETE：从服务器删除资源。
	- 请求内容：URL 中携带的参数必须无敏感信息或符合安全要求。
	- 响应体：响应体 body 中可放置多种数据类型，由 Content-Type 头确定。
	- 状态码：使用语义清晰统一的状态码。
- 【强制】Service 层方法的返回值禁止直接返回响应体对象。且至少返回 boolean 类型，标识是否执行成功。如果前后端数据列表相关的接口执行结果为空，返回 null。
- 【强制】响应对象的构造统一由 Controller 层完成，Controller 层从 Service 层获取数据，如果获取前后端数据列表相关的接口数据为 null，构造响应对象返回空数组 [] 或空集合 {}，不允许返回null。
- 【强制】服务端发生错误时，返回给前端的响应信息必须包含 HTTP 状态码，错误码 Code、错误信息 Message、用户提示信息四个部分。
	- HTTP 状态码：受众对象为浏览器。供浏览器获取和解析。常见状态码如下：
		- 200：OK。表明该请求已经成功完成，所请求的资源已经成功发送到客户端。
		- 401：Unauthorized。表明此请求需要身份验证，常见于需要用户登录而用户未登录时。
		- 403：Forbidden。表明服务器拒绝此请求，常见于访问机密信息或复制其它登录用户链接访问服务器的情况。
		- 404：Not Found。表明服务器无法取得所请求的资源，即请求资源不存在。
		- 500：Internal Server Error。表明服务器内部出现了错误。
	- 错误码 Code：受众对象为前端开发人员。详细错误码定义请参考自定义或已约定的错误码列表。
	- 错误信息 Message：受众对象为错误排查人员。需简要描述后端出错原因，便于错误排查人员快速定位问题，注意不能包含敏感数据信息。
	- 用户提示信息：受众对象为用户。且输出给用户的提示信息要求简短清晰，提示友好，能够引导用户进行下一步操作或明确错误原因。
- 【强制】在需要前后端交互的 JSON 格式数据中，所有的 key 命名时必须采用小驼峰命名法，且符合英文表达习惯，表意完整。
- 【强制】需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用 Long 类型返回。因为前端在接收到 Long 类型的数据后，JS 会自动转换其为 Number类型（此类型为双 精度浮点数，表示原理与取值范围等同于 Java 中的 Double 类型）。Long 类型能表示的最大值是 2^63 - 1。如若在 Long 类型的取值范围之内，超过 2^53 = 9007199254740992 的数值，转化为 JS 的 Number 时，数值上会有精度损失。
	- 通常在数值大于等于 16 位时，可能会出现前后端数值不一致的情况。
- 【强制】HTTP请求通过 URL 传递参数时，参数大小不能超过 2048B( = 2KB)。因为不同浏览器对于 URL 的最大长度限制略有不同，对超出最大长度的处理逻辑也各有差异，2048 字节是取所有浏览器的最小值。
- 【强制】HTTP请求通过 body 传递内容时，必须控制长度。超出最大长度后，后端解析会出错。
	- nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传递较大内容时，请调整服务器端的默认限制。
- 【强制】在分页场景中，若用户输入的页码参数小于 1，则后端处理为第一页的页码参数；若用户输入的页码参数大于总页数，则后端处理为最后一页的页码参数。
- 【强制】服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL 统一代理模块生成，否则会因线上采用 HTTPS 协议导致浏览器提示 ”不安全”，并且会带来 URL 维护不一致的问题。
- 【强制】前后端的时间格式统一为 yyyy-MM-dd HH:mm:ss，GMT。
- 【强制】为查询列表类接口返回响应时，必须对查询结果集做排序操作，一般按主表创建或更新时间降序排序。
## 其他规约
- 【强制】在使用正则表达式时，利用其预编译功能加快正则匹配速度。不允许在方法体内直接定义和使用字符串形式的正则表达式，因为在方法体内定义正则规则会导致每次调用方法时都产生编译开销。应将编译好的正则 Pattern 定义为静态常量，供重复使用。
	- 当使用 String.matches("正则字符串") 时，内部实际上会先编译这个正则表达式，然后创建一个 Pattern 对象，并在使用完毕后回收。如果在方法体中使用 String.matches()，会导致每次都需要重新编译。而编译正则表达式是需要耗费 CPU 资源的，它需要将正则表达式解析成一个状态机。
- 【强制】Java Spring项目中，进行对象属性的浅拷贝时的最佳实践是使用 Spring BeanUtils，如果对性能要求特别高，考虑使用 Cglib BeanCopier。
	- 避免使用 Apache Beanutils 进行属性拷贝，因为 Apache Beanutils 频繁使用反射，且每次拷贝都要进行类型转换，导致性能开销较大。
	- Spring BeanUtils 性能比Apache BeanUtils 好很多，且功能灵活、异常处理更友好、可以忽略特定属性。在spring 项目中最推荐使用。
	- Cglib BeanCopier 性能最好，通过生成字节码来实现拷贝，没有反射调用。
- 【强制】引用数据类型的判空，在 SpringBoot 项目中统一使用 `org.springframework.util` 提供的工具类中的：`ObjectUtils.isEmpty()` 方法。
- 【推荐】任何数据结构的构造或初始化，尽可能为其指定大小，尤其是 Java 中的集合类型。
	- ArrayList 默认初始容量是10，当元素数量超过容量时，会触发扩容（默认每次扩容增加50%），每次扩容时需要创建新数组并复制数据，比较耗费性能，通过预先指定大小的方式避免多次扩容。
	- HashMap 默认初始容量是16，当元素数量超过负载因子（默认 0.75）时会触发扩容和rehash，rehash 操作非常耗性能，需要重新计算所有元素的位置。
- 【推荐】及时清理不再使用的代码段或配置信息。对于暂时被注释掉、后续可能恢复使用的代码片段，请在注释代码上方统一使用三个斜杠 （///） 说明注释掉代码的理由。
# 异常日志
## 错误码
- 【强制】错误码的制定原则是：快速溯源 + 沟通标准化。
	- 错误码回答的问题：错误是什么？为什么错或错在哪？
	- 错误码的制定原则：
		- 必须能够快速知晓错误来源并快速判断是哪里的问题。
		- 错误码必须能够进行清晰地比对（代码中容易 equals）。
		- 错误码组成的列表不宜冗长繁杂。相同或足够相近语义的错误码不要重复定义。
		- 错误码必须有利于团队快速对错误原因达成一致认知。
	- 错误码的制定注意事项：
		- 错误码不体现版本号和错误等级信息。错误码以不断追加的方式进行兼容，错误等级由日志和错误码本身的释义来决定。
		- 错误码不与公司的业务架构和组织架构挂钩，以先到先得的原则在统一平台上进行，且错误码一旦审批生效，编号即被永久固定。
		- 错误码使用者应避免随意定义新的错误码，而是尽可能在原有错误码附表中找到语义相同或者相近的错误码使用即可。
	- 错误码的使用场景：
		- 错误码不能直接输出给用户作为提示信息使用。错误码中体现的业务独特内容由错误信息承载，而不让错误码本身涵盖过多具体业务属性。
## 异常处理
- 【强制】业务开发中必须严格防止空指针异常。参数校验，尤其是参数的非空校验，要始终确保合理、无遗漏。常见引发空指针异常的情形如下：
	- 数据库的查询结果为 null。
	- 集合对象本身为 null、集合中的元素个数为 null、集合中取出的数据元素为 null。
	- 远程调用返回的对象为 null。
- 【强制】非必要不允许抛出 new RuntimeException()，不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。
	- 业务中常见的自定义异常：DAOException、ServiceException。
## 日志规约
- 【强制】所有日志文件应至少保存 15天，因为有些异常具备以周为频次发生的特点。对于当天产生的日志，以 ”应用名.log” 保存，保存在 ./项目路径/logs/目录下。其他日期的日志格式统一为：{日志名称}.log.{保存日期}，日期格式：yyyy-MM-dd。
- 【强制】有关国家法律、网络运行状态、网络安全事件、个人敏感信息操作等的相关记录，留存日志的时间不能少于六个月，必要时进行多机备份。
- 【强制】生产环境禁止使用 System.out 或 System.err 输出日志，禁止使用 e.printStackTrace() 打印异常堆栈。
- 【强制】谨慎地记录日志，不要大量输出无效日志。生产环境非必要禁止输出 debug 日志、有选择地输出 info 日志。要格外注意日志输出量的问题，避免大量写入服务器磁盘，并及时清理无用的日志。
	- 大量地输出无效日志对系统性能不利，而且不利于快速定位错误点。
	- 记录日志时请思考：这写日志真的有人看吗？看到这条日志能做什么？这条日志能不能给问题排查带来好处？
# 单元测试
- 【强制】单元测试必须遵守 AIR 原则。即单元测试在线上运行时，要像空气（AIR）一样感觉不到，但在测试质量的保障上非常关键。单元测试从宏观上说，要具有自动化（Automatic）、独立性（Independent）、可重复执行（Repeatable）的特点。
- 【强制】单元测试必须非交互式地全自动执行，因为测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。且输出结果中禁止使用 System.out 来进行人工验证，必须使用 assert 进行验证。
- 【强制】保持单元测试的独立性，要保证单元测试稳定可靠且便于维护。单元测试用例之间禁止互相调用，也不能依赖执行的先后次序。
- 【强制】单元测试中要保证测试粒度足够小，才有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。
	- 单测不负责检查跨类或者跨系统的交互逻辑，由集成测试负责。
- 【强制】核心业务、核心应用和核心模块的代码必须保证单元测试通过。
# 安全规约
- 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏或过滤。
	- 中国大陆个人手机号码隐藏中间 4 位，防止隐私泄露。
- 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止SQL注入。禁止字符串拼接 SQL 访问数据库。
- 【强制】用户传入的任何请求参数必须做有效性验证及参数校验。
- 【强制】表单、AJAX 提交必须执行 CSRF 安全验证。
	- CSRF（Cross-site request forgery）跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用或网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便能在用户不知情的情况下对数据库中的用户参数进行修改。
- 【强制】URL 外部重定向传入的目标地址必须执行白名单过滤。
- 【强制】在使用平台资源比如短信、邮件、电话、下单、支付等，必须实现正确的防重放机制。如数量限制、疲劳度控制、验证码校验，避免被滥刷。
	- 如注册时发送验证码到手机，如果没有限制次数和频率，可以利用此功能骚扰其它用户，并造成短信平台资源浪费。
- 【强制】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。
# MYSQL 数据库
## 建表规约
- 【强制】任何字段，如果为非负数，必须约束为 unsigned。
- 【强制】数据库名、表名、 字段名，均使用字母全小写 + 单词间下划线分隔的方式命名。不允许出现大写字母。且禁止两个下划线中间只出现数字。
- 【强制】表名命名时，不能使用复数名词。表名应当仅表示表中的实体内容，不应该表示实体数量。对应于 DO 类中的类名，也必须是单数形式。
- 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名为 idx_字段名。
	- pk：即 primary key
	- uk：即 nique key
	- idx：即 ndex
- 【强制】MYSQL中存储小数时，类型必须为 decimal，禁止使用 float 和 double，避免精度损失引起的结果误差。
- 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。因为 char 的长度是固定的，在数据的读取和写入操作上，速度相对稳定。当数据长度比较固定，且经常需要进行读取操作时，char 类型会更高效。
- 【强制】varchar 是可变长字符串，存储特点是根据实际存储的字符数来分配空间，而不预先为最大长度分配固定大小的存储空间（但仍然受到长度限制）。其长度最大不能超过 5000。如果存储长度大于此值，请定义字段类型为 text，并独立出一张表，用主键关联，避免影响操作其它字段的效率。
- 【强制】每张表都必须拥有三个字段：id，create_time，update_time。
	- id 为主键（PRIMARY KEY），类型为 `bigint unsigned` 或 `int unsigned`，单表时自增（AUTO_INCREMENT），步长为1。
	- create_time 和 update_time 的类型均为 `datetime` 类型。且每次更新记录时，使用 `default current_timestamp on update current_timestamp`自动更新当前时间。
- 【强制】表的命名如非必要，请遵循：`业务名称_表的作用`格式。
- 【强制】库名与项目名如非必要，请保持一致。
- 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才考虑进行分库分表。如果预计三年后的数据量达不到这个级别，请不要在创建表时就分库分表。
## 索引规约
- 【强制】业务上具有唯一特性的字段，必须约束为唯一索引以提高查询性能，避免脏数据的产生。
- 【强制】当进行多表关联查询时，禁止超过三个表的`JOIN`操作以保证查询的性能。如果确实需要查询多个表，请考虑拆分查询或使用子查询。
- 【强制】多表关联查询时，需要`JOIN`的字段，数据类型必须保持一致，且被关联的字段必须拥有索引。
- 【强制】在对 varchar 字段建立索引时，必须根据字段中实际数据的特点及文本区分度，显式指定索引长度。此索引长度需保证文本区分度大于等于 90%，以 100% 为理想情况。通过限制索引长度，只对字段的前几个字符进行索引，不必要对全字段建立索引。
	- 计算文本区分度 ratio 的 SQL 查询语句：计算在指定行中，取前 `索引长度` 个字符后不同值的个数与总行数的比例。能够衡量列中提取的前 `索引长度` 个字符的多样性。
```sql
SELECT count(distinct left(列名, 索引长度))/count(*) AS ratio FROM 表名;
```
- 【强制】严格考虑索引失效的情况，避免索引无法命中。
- 【强制】SQL性能优化的目标：执行计划中的连接类型至少达到 range 级别，要求是 ref 级别，以 consts 最佳。尽可能避免全表扫描。
	- range：当一个查询使用了范围查询如 `BETWEEN`、`>`、`<` 等，数据库会使用索引查询匹配符合条件的行。`range`表示查询是通过索引范围扫描来执行的。这个等级比全表扫描要高效，因为它利用了索引，但是查询的效率不如`ref`或`consts`。
	- ref：`ref`表示查询使用了非唯一索引（普通索引 normal index），并且只匹配一个单一的值（比如主键或唯一索引的一部分）。这是比`range`更高效的一种查询方式，通常是在查询条件中使用了带有等值比较的字段。它比`range`扫描更精确。
	- consts：`const`表示查询条件是完全常量的，并且数据库可以将整个查询优化为常数查找。即数据库在查询时可以通过索引直接定位到唯一的行，查询效率非常高。
- 【强制】定期使用 Explain 分析查询 SQL 的执行计划，确保查询尽可能采用更高效的索引扫描方式。
## SQL语句
- 【强制】使用`ISNULL()`判断是否为 NULL 值。因为`NULL`与任何值的直接比较都为`NULL`，而不是`true`或`false`。
- 【强制】禁止使用物理外键与级联更新，一切外键概念必须在应用层使用逻辑外键，级联更新场景必须在应用层手动更新。
	- 物理外键与级联更新适用于单机和低并发环境，不适合分布式、高并发集群。
	- 级联更新是强阻塞，存在数据库更新风暴的风险。
	- 物理外键影响数据库的插入速度。
## ORM映射
- 【强制】在查询 SQL 中，禁止使用 * 作为查询的字段列表，需要查询哪些字段必须明确写明。
	- 原因一：增加查询分析器解析成本。
	- 原因二：增减字段后容易与实体类或 resultMap 配置不一致。
	- 原因三：无用字段增加网络消耗，尤其是 text 类型的字段。
# 工程结构
## 应用分层
- 【强制】Service 层出现异常时，必须记录异常日志到磁盘，且尽可能带上参数信息，便于分析问题。
- 【强制】Controller 层必须将异常处理为错误码和错误信息的形式返回前端。
## 依赖
- 【强制】禁止使用不稳定的工具包或者 Utils 类。
## 服务器
- 【推荐】高并发服务器请调小 TCP 协议的 time_wait 超时时间。避免在高并发访问下，服务器端因为处于 time_wait 的连接数太多，导致无法建立新的连接。
- 【推荐】为 JVM 环境的启动参数设置 -XX:+HeapDumpOnOutOfMemoryError 参数，使 JVM 发生Out Of Memory 内存溢出崩溃时输出堆信息。
- 【推荐】web 后端项目的开放端口避免使用常见或易冲突的端口，建议选择 1024-49151 范围内的端口。
	- 端口号是用于标识网络服务的逻辑地址，总共有 65536 个，范围是从 0 到 65535。
	- **公认端口（Well - Known Ports）**：范围从 0 到 1023。这些端口号通常分配给一些常见的网络服务，例如 HTTP 服务使用 80 端口，HTTPS 服务使用 443 端口，FTP 服务使用 20 和 21 端口，SMTP 服务使用 25 端口等。这些端口号的分配是由互联网号码分配机构（IANA）统一管理的，能够让不同的网络服务使用固定的端口号进行通信，方便用户和网络设备进行识别和连接。
	- **注册端口（Registered Ports）**：范围是从 1024 到 49151。这些端口号被应用程序开发者用于注册自己的应用程序服务。虽然这些端口号不是由 IANA 直接分配给特定的服务，但它们需要在 IANA 进行注册，以避免与其他应用程序的端口号冲突。例如一些数据库服务、邮件客户端等可能会使用注册端口来提供特定的功能。
	- **动态和 / 或私有端口（Dynamic and/or Private Ports）**：范围是从 49152 到 65535。这些端口号通常被操作系统或应用程序动态分配使用，用于临时的网络连接。例如，当用户使用浏览器访问一个网站时，浏览器会从动态端口范围内选择一个未被占用的端口号与网站的服务器进行连接。这些端口号不需要事先注册，并且在连接结束后可以被其他应用程序再次使用。
## 部署
- 【强制】使用 Docker 部署项目时，挂载目录统一指定到` /home/项目名/目录` 下，即在 `/home` 目录下管理所有项目的挂载文件。
- 【强制】用户在本地安装的软件，安装目录统一指定到 `/usr/local` 目录下。
# 设计规约
- 【强制】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。
- 【强制】设计文档的作用是明确需求、梳理逻辑和后期维护，次要目的是用于指导编码。
- 【强制】注重系统的可扩展性。可扩展性的本质是找到系统的变化点，并隔离变化点。
	- 所有提出的设计模式解决的只有一个问题：就是如何隔离变化点。
	- 达到完美可扩展性的标志，就是需求的新增不会在原有代码交付物上进行任何形式的修改。
- 【强制】设计的本质是识别和表达系统难点。需要识别到系统难点，然后进行准确地表达。
### 日志
### 用户操作日志
- 【强制】用户操作日志要记录所有用户在系统中的操作过程和操作结果。能够回答：`谁在什么时间？什么位置？对什么东西做了什么操作？产生了哪些变动？`等系列问题。包含信息如下：
	- 用户或操作人 id
	- 操作时间
	- 操作名称
	- 操作类型：记录具体操作的类型。如登录、查询、新增、删除、修改、导入、导出等。
	- 操作结果：记录用户操作的结果，成功、失败。
	- 变动值：在执行该操作后发生了什么变化，主要针对修改类型的操作。
	- 请求路径：记录执行操作时调用的接口路径。
	- 用户 IP：记录用户在执行操作时的 IP 地址。
	- 设备信息：记录用户通过什么设备执行的操作。如使用的操作系统、浏览器。
	- 请求参数：用户发起请求时传递的请求参数。
	- 响应参数：服务端返回的响应。
- 【强制】用户日志应具备自动清理功能，避免累计大量数据。
	- 按最大日志条数自动清理：当日志达到 n 条时，清理最早的 m 条数据，其中，m 为日志总量 - n。
		- 优点：以数量为核心控制维度，侧重对存储规模做限制。
		- 缺点：时间跨度不可控，可能丢失早期重要日志。
		- 适用场景：
			- 日志密度较低或波动不大，且对日志保留时间要求不高的系统。
			- 日志多用于辅助调试的系统。
	- 按最大存储天数自动清理：清理 n 天前的操作日志。
		- 优点：以时间为核心控制维度，侧重对数据保留周期做限制。
		- 缺点：数据量不可控，可能造成存储膨胀。
		- 适用场景：
			- 合规性要求保留日志一定时间（如安全审计、系统监管）。
			- 日志用于分析业务行为，需覆盖一定周期。
			- 存储资源相对宽裕，优先考虑留存信息而非存储成本。
	- 综合最大条数和最大天数自动清理：
		- 当日志达到 n 条且存在 m 天前的数据，清理超出部分。
			- 优点：数据保留更谨慎。尽可能多保留日志，延迟清理，减少重要日志丢失。
			- 缺点：可能滞后触发清理。只有在“日志超多”且“存在老数据”时才清理，有可能造成暂时性存储压力。
		- 当日志达到 n 条或存在 m 天前的数据，清理超出部分。
			- 优点：兼顾时间跨度与数据量的更均衡折中方案。既控制磁盘使用，同时避免老旧数据堆积。
			- 缺点：在极端高频写入的系统中存在数据丢失风险。
# 版本控制
- 【强制】项目中必须有主分支和辅助分支。
	- 主分支如：master、main，用于正式版本代码归档。
	- 辅助分支如：develop，用于日常开发。
- [【参考资料】](https://developer.aliyun.com/article/1599147#:~:text=%E6%9C%AC%E6%96%87%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%88%B6%E5%AE%9AGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%9A%84Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B%EF%BC%8C%E6%97%A8%E5%9C%A8%E9%80%9A%E8%BF%87%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84Git%E6%93%8D%E4%BD%9C%E4%BF%83%E8%BF%9B%E5%9B%A2%E9%98%9F%E9%AB%98%E6%95%88%E5%8D%8F%E4%BD%9C%E3%80%81%E7%A1%AE%E4%BF%9D%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8C%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%E3%80%82,%E4%B8%BA%E4%BD%95%E5%88%B6%E5%AE%9A%E8%A7%84%E8%8C%83%EF%BC%9A%E8%A7%84%E8%8C%83%E6%9C%89%E5%8A%A9%E4%BA%8E%E5%8A%A0%E9%80%9F%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%EF%BC%8C%E7%A1%AE%E4%BF%9D%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%EF%BC%8C%E7%BB%B4%E6%8A%A4%E4%B8%BB%E5%88%86%E6%94%AF%E7%A8%B3%E5%AE%9A%EF%BC%8C%E6%94%AF%E6%8C%81%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BE%BF%E4%BA%8E%E9%97%AE%E9%A2%98%E8%BF%BD%E8%B8%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E6%96%B0%E4%BA%BA%E8%9E%8D%E5%85%A5%EF%BC%8C%E5%8F%8A%E4%BF%83%E8%BF%9B%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E3%80%82)